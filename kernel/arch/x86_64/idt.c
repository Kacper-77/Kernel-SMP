#include <idt.h>
#include <apic.h>
#include <cpu.h>
#include <serial.h>
#include <timer.h>
#include <panic.h>
#include <sched.h>
#include <spinlock.h>

static struct idt_ptr idtr;
static struct idt_entry idt[256];

// Generated by NASM
extern uint64_t isr_stub_table[];

void exception_handler(interrupt_frame_t* frame) {
    uint64_t cr2;
    __asm__ volatile("mov %%cr2, %0" : "=r"(cr2));

    kprint("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
    kprint("!!!          CPU EXCEPTION         !!!\n");
    kprint("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
    kprint("Vector: ");        kprint_hex(frame->vector_number);
    kprint(" | Error Code: "); kprint_hex(frame->error_code);
    kprint("\nRIP:    ");      kprint_hex(frame->rip);
    kprint("\nCR2 (Fault Address): "); kprint_hex(cr2);
    kprint("\nRAX:    ");      kprint_hex(frame->rax);
    kprint(" | RBX: ");        kprint_hex(frame->rbx);
    kprint("\nStack at: ");    kprint_hex(frame->rsp);
    kprint("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
    
    panic("Unhandled CPU Exception");
}

void idt_set_descriptor(uint8_t vector, void* isr, uint8_t flags) {
    uintptr_t addr = (uintptr_t)isr;
    idt[vector].isr_low    = addr & 0xFFFF;
    idt[vector].kernel_cs  = 0x08; // Kernel Code Segment
    idt[vector].ist        = 0;
    idt[vector].attributes = flags;
    idt[vector].isr_mid    = (addr >> 16) & 0xFFFF;
    idt[vector].isr_high   = (addr >> 32) & 0xFFFFFFFF;
    idt[vector].reserved   = 0;
}

uint64_t interrupt_dispatch(interrupt_frame_t* frame) {
    uint64_t next_rsp = (uint64_t)frame;

    if (frame->vector_number < 32) {
        exception_handler(frame);
    } else if (frame->vector_number == 32) {
        if (get_cpu()->cpu_id == 0) system_uptime_ms += 10;

        lapic_send_eoi();
        next_rsp = schedule(frame);
    } else if (frame->vector_number == IPI_VECTOR_TEST) {
        extern spinlock_t kprint_lock_;
        spin_lock(&kprint_lock_);

        kprint("IPI Received on CPU ");
        kprint_hex(get_cpu()->cpu_id);
        kprint("\n");
        
        spin_unlock(&kprint_lock_);

        lapic_send_eoi();
    } else if (frame->vector_number == IPI_VECTOR_HALT) {
        __asm__ volatile("cli");
        for(;;) __asm__ volatile("hlt");
    } else {
        lapic_send_eoi();
    }

    return next_rsp;
}

void idt_init() {
    for (int i = 0; i < 256; i++) {
        idt_set_descriptor(i, (void*)isr_stub_table[i], 0x8E);
    }

    idtr.base = (uintptr_t)&idt[0];
    idtr.limit = (uint16_t)sizeof(idt) - 1;

    __asm__ volatile ("lidt %0" : : "m"(idtr));
    kprint("IDT: 256 vectors registered.\n");
}
